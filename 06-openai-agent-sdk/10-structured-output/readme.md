# **Structured Output**

A structured output tells your agent exactly what data shape to return—so instead of free‑form text, you get typed, machine‑readable objects. This guide explains why structured outputs matter, how Pydantic makes it easy, and walks through examples from basic to advanced.

## **What Is Structured Output:**

When you build an agent, you can specify an output_type—a Python data model that defines the exact fields and types your agent must return. Under the hood:

- The SDK instructs the LLM to emit JSON matching your schema.
- It uses Pydantic to parse and validate that JSON into a Python object.

Without structured output, agents return a plain string. With it, you get a Python instance (or a basic type) you can use directly in your code.

## **What Is Pydantic:**

Pydantic is a Python library for data parsing and validation using type hints. In the Agent SDK, Pydantic’s BaseModel (or any type Pydantic’s TypeAdapter supports) becomes the single source of truth for your output schema:

```py
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name: str
    email: str

# When used as output_type=User, the agent will emit JSON like:
{"id": 42, "name": "Alice", "email": "alice@example.com"}
```

## **Understanding OpenAI Agent Outputs:**

When you invoke an agent via the SDK (e.g. using Runner.run_sync or Runner.run), you receive back a RunResult object containing all the details of that execution. Two modes of output are supported:

1. Free‑form text — the default
2. Structured data — via Pydantic models for predictable, machine‑readable results

## **Key Fields on RunResult**

After running an agent (Runner.run_sync or run_async), you get a RunResult object with:

- **final_output:** The agent’s ultimate answer.

  - str (by default)
  - An instance of your Pydantic model (when you set output_type)

- **new_items:** A list of every intermediate step the agent took:

  - Messages generated by the LLM
  - Tool‑call requests
  - Tool outputs
  - Handoff events

- **input / to_input_list():** The original prompt plus the full “chat history” of messages and tool results.

  - Use result.input to see the raw prompt string.
  - Use result.to_input_list() to get a list of message dicts you can feed into a follow‑up turn.

  ```py
    # By default, agents return plain text:

    agent = Agent(
        name="EchoBot",
        instructions="Repeat the user’s message."
    )
    result = Runner.run_sync(agent, "Hello!")
    print(type(result.final_output))  # str


    # To enforce a predictable schema, define a Pydantic model and pass it as output_type:

    class Echo(BaseModel):
        echoed: str

    agent = Agent(
        name="EchoBot",
        instructions="Return JSON with field `echoed` containing the user message.",
        output_type=Echo
    )
    result = Runner.run_sync(agent, "Hello!")
    print(type(result.final_output))  # Echo
    print(result.final_output.echoed)  # "Hello!"

  ```

## **Structured Outputs with Pydantic Models**

1. **Basic Pydantic:**

   ```py
   from pydantic import BaseModel
   from agents import Agent, Runner

   class SumResult(BaseModel):
       result: int

   agent = Agent(
       name="Adder",
       instructions="Add two numbers and return JSON with `result`.",
       output_type=SumResult
   )
   result = Runner.run_sync(agent, "Add 8 and 5.")
   # result.final_output -> SumResult(result=13)
   ```

2. **Dataclass Support:**

   ```py
   from dataclasses import dataclass
   from agents import Agent, Runner

   @dataclass
   class Greet:
       greeting: str

   agent = Agent(
       name="Greeter",
       instructions="Return a greeting in JSON `{greeting: ...}`.",
       output_type=Greet
   )
   output = Runner.run_sync(agent, "Say hello.").final_output
   # output -> Greet(greeting="Hello!")
   ```

3. **TypedDict:**

   ```py
   from typing import TypedDict
   from agents import Agent, Runner

   class Weather(TypedDict):
       city: str
       temperature: float

   agent = Agent(
       name="WeatherFetcher",
       instructions="Return JSON with `city` and numeric `temperature`.",
       output_type=Weather
   )

   output = Runner.run_sync(agent, "Weather in Berlin?")
   # -> {"city":"Berlin", "temperature":18.5}
   ```

4. **List of Models:**

   ```py
   from pydantic import BaseModel
   from typing import List
   from agents import Agent, Runner

   class Task(BaseModel):
       id: int
       description: str

   agent = Agent(
       name="TaskLister",
       instructions="List three tasks as JSON array of objects `{id, description}`.",
       output_type=List[Task]
   )
   tasks = Runner.run_sync(agent, "Give me three chores.")
   # tasks -> [Task(id=1,...), Task(id=2,...), Task(id=3,...)]

   ```

5. **Nested Models:**

   ```py
   from pydantic import BaseModel
   from typing import List
   from agents import Agent, Runner

   class Attendee(BaseModel):
       name: str
       rsvp: bool

   class Event(BaseModel):
       title: str
       attendees: List[Attendee]

   agent = Agent(
       name="EventPlanner",
       instructions="Return JSON with `title` and list of `attendees` (name + rsvp).",
       output_type=Event
   )
   ev = Runner.run_sync(agent, "Create an event 'Meeting' with two attendees.").final_output
   # ev.attendees -> [Attendee(...), Attendee(...)]

   ```

## **Working with Different Output Types**

- Primitive types: int, str, float.
- Containers: List[T], Dict[str, T].
- Pydantic/BaseModel and dataclasses.
- TypedDict or any type supported by Pydantic’s TypeAdapter.

The SDK will raise a clear validation error if the LLM response doesn’t match your schema, so you can handle it in code rather than parsing strings at runtime.

## **Handling Validation Errors:**

If the agent’s JSON doesn’t match your schema, Pydantic raises a ValidationError. Catch it to handle unexpected outputs:

```py
from pydantic import ValidationError

try:
    result = Runner.run_sync(agent, "...")
    data = result.final_output
except ValidationError as e:
    print("Agent returned invalid data:", e)
```

## **Benefits of Structured Outputs**

- Predictability: You always know the fields and types you get back.
- Error Handling: Invalid JSON becomes an exception you can catch.
- Seamless Integration: Directly insert results into databases or APIs.
- Clear Docs: Your Python models serve as living documentation.
- Testable: Write unit tests against your data models, not text parsing.

By using structured outputs, you transform your agents into robust, type-safe services—no more fragile text parsing, just clean data you can trust.
